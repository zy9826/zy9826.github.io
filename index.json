[{"categories":["汇编语言"],"content":"环境安装和调试指令 DosBox直接安装, MASM文件夹（包含调试工具）拷贝到D盘 设置DosBox窗口大小 到安装路径运行DOSBox 0.74 Options.bat, 修改以下两行 windowresolution=1000x1300 output=ddraw 运行DosBox 输入以下命令挂载工具目录到C: mount c d:masm 进入到C: c:; 运行debug模式 debug debug模式的常用命令 r: register, 查看或改变CPU寄存器的内容 d: dump, 查看内存中的内容 e: enter, 改写内存中的内容 u: unassemble, 将内存中的机器指令翻译成汇编指令 t: trace, 执行一条机器指令 a: assemble, 以汇编指令的格式在内存中写入一条机器指令 ","date":"2025-06-07","objectID":"/notebook/7c53d0359678/:1:0","tags":["汇编语言"],"title":"DosBox安装和汇编基础","uri":"/notebook/7c53d0359678/"},{"categories":["汇编语言"],"content":"寄存器表 AH\u0026AL = AX(accumulator)：累加寄存器 BH\u0026BL = BX(base)：基址寄存器 CH\u0026CL = CX(count)：计数寄存器 DH\u0026DL = DX(data)：数据寄存器 SP (Stack Pointer)：堆栈指针寄存器 BP (Base Pointer)：基址指针寄存器 SI (Source Index)：源变址寄存器 DI (Destination Index)：目的变址寄存器 IP (Instruction Pointer)：指令指针寄存器 CS (Code Segment)：代码段寄存器 DS (Data Segment)：数据段寄存器 SS (Stack Segment)：堆栈段寄存器 ES (Extra Segment)：附加段寄存器 ","date":"2025-06-07","objectID":"/notebook/7c53d0359678/:2:0","tags":["汇编语言"],"title":"DosBox安装和汇编基础","uri":"/notebook/7c53d0359678/"},{"categories":["汇编语言"],"content":"标志寄存器 OF overflow flag 溢出标志: 操作数超出机器能表示的范围表示溢出，溢出时为1. DF（方向标志）：用于串处理。DF=1时，每次操作后使SI/DI减小；DF=0时则增大。 IF（中断标志）：IF=1时，允许CPU响应可屏蔽中断，否则关闭中断。 TF（陷阱标志）：用于调试单步操作。 SF sign flag 符号标志: 记录运算结果的符号，结果为负时SF=1，否则SF=0。 ZF zero flag 零标志: 运算结果等于0时ZF=1，否则ZF=0。 AF（辅助进位标志）：运算时，第3位向第4位产生进位时为1，否则为0。 PF parity flag 奇偶标志: 运算结果操作数位为1的个数为偶数个时PF=1，否则PF=0。 CF carry flag 进位标志：最高有效位产生进位时CF=1，否则CF=0。 0/1 OF DF SF ZF AF PF CF 1 OV DN NG ZR PE CY 0 NV UP PL NZ PO NC ","date":"2025-06-07","objectID":"/notebook/7c53d0359678/:2:1","tags":["汇编语言"],"title":"DosBox安装和汇编基础","uri":"/notebook/7c53d0359678/"},{"categories":["汇编语言"],"content":"溢出标志具体检测方法 CPU 在执行加法指令后，会检查两个操作数的最高位（符号位）和结果的最高位。如果两个操作数的符号位相同，而结果的符号位与操作数的符号位不同，就设置溢出标志。 例如，对于两个 8 位有符号数 A 和 B，其符号位分别为 A7 和 B7，结果的符号位为 S7。如果 A7 = B7 且 A7 ≠ S7，就设置溢出标志。 OF=0, CF=1 : D0h+E0h OF=1, CF=0 : 7Fh+01h=80(-128) OF=1, CF=1 : 90h+90h ","date":"2025-06-07","objectID":"/notebook/7c53d0359678/:2:2","tags":["汇编语言"],"title":"DosBox安装和汇编基础","uri":"/notebook/7c53d0359678/"},{"categories":["汇编语言"],"content":"常用指令 mov, 赋值指令; mov ax,100 add, 加法指令, add指令溢出后高位舍弃; add ax,100 sub, 减法指令, sub指令溢出后高位舍弃; sub ax,100 and, 按位与指令; and ax,3333h or, 按位或指令; or ax,3333h shl/shr, 逻辑左移/右移指令, 功能如下: 将一个寄存器或内存单元中的数据向左移位 将最后移出的一位写入CF中, 最低位用0填充 例: shl ax,1; 使用立即数时只能移动一位 移动多位需要使用寄存器, 例: mov cl, 3 shl ax, cl inc: 自增1 inc ax dec: 自减1 dec ax nop: 空指令 xchg: 交换指令 xchg ax,bx neg: 算术取反 neg ax int: 中断 int 21h 退出程序 ds寄存器不能赋值立即数 mov ax,21F0h mov ds,ax mov [0],ax jmp: 跳转指令, 修改CS:IP jmp ax jmp 1000:3 ","date":"2025-06-07","objectID":"/notebook/7c53d0359678/:3:0","tags":["汇编语言"],"title":"DosBox安装和汇编基础","uri":"/notebook/7c53d0359678/"},{"categories":["汇编语言"],"content":"mul指令 mul是乘法指令, 需要注意的是: 两个相乘的数要么都是8位,要么都是16位. 如果是8位一个默认放在AL中, 另一个放在8位reg或内存单元中; 如何是16位, 一个默认在AX中, 另一个放在16位reg或内存单元中. 结果: 如果是8位乘法, 结果默认放在AX中; 如果是16位乘法, 结果高位默认存放在DX中, 低位存放在AX中 ","date":"2025-06-07","objectID":"/notebook/7c53d0359678/:3:1","tags":["汇编语言"],"title":"DosBox安装和汇编基础","uri":"/notebook/7c53d0359678/"},{"categories":["汇编语言"],"content":"div指令 div是除法指令, 使用此指令是应注意以下问题: 除数, 有8位和16位两种, 在一个reg或内存单元中 被除数, 默认放在 AX 或 DX和AX 中, 如果除数位8位, 被除数则为16位, 默认放在AX中存放; 如果除数为16为, 被除数则为32位, 在DX和AX中存放, DX放高16位, AX放低16位. 举例: div byte ptr ds:[0] (al)=(ax)/(ds10h+0) ;商 (ah)=(ax)/(ds10h+0) ;余数 ","date":"2025-06-07","objectID":"/notebook/7c53d0359678/:3:2","tags":["汇编语言"],"title":"DosBox安装和汇编基础","uri":"/notebook/7c53d0359678/"},{"categories":["汇编语言"],"content":"栈 push ax的执行有以下两步完成: SP=SP-2, SS:SP指针移动 将ax中的内容送入SS:SP指向的内存单元处, SS:SP不变 pop ax的执行有以下两步完成: 将SS:SP指向的内存单元处的数据送入ax中 SP=SP+2, SS:SP指针移动 ","date":"2025-06-07","objectID":"/notebook/7c53d0359678/:4:0","tags":["汇编语言"],"title":"DosBox安装和汇编基础","uri":"/notebook/7c53d0359678/"},{"categories":["汇编语言"],"content":"寻址方式 ","date":"2025-06-07","objectID":"/notebook/7c53d0359678/:5:0","tags":["汇编语言"],"title":"DosBox安装和汇编基础","uri":"/notebook/7c53d0359678/"},{"categories":["汇编语言"],"content":"bx和bp寄存器 bx: 基址寄存器, 默认以ds为段地址 bp: 基址指针寄存器, 如果不显示指定段地址, 则默认以ss为段地址 [bx+idata] : mov ax,[bx+1] [bx]可以指向一个内存单元, +1是偏移地址: ","date":"2025-06-07","objectID":"/notebook/7c53d0359678/:5:1","tags":["汇编语言"],"title":"DosBox安装和汇编基础","uri":"/notebook/7c53d0359678/"},{"categories":["汇编语言"],"content":"si和di寄存器 si,di寄存器是和bx功能相似的寄存器, si和di不能分成两个8位寄存器来使用 [bx+si] : mov ax,[bx+si] [bx+di] : mov ax,[bx+di] [bx+si/di+idata] : mov ax,[bx+si+16] ","date":"2025-06-07","objectID":"/notebook/7c53d0359678/:5:2","tags":["汇编语言"],"title":"DosBox安装和汇编基础","uri":"/notebook/7c53d0359678/"},{"categories":["draft"],"content":"需求：将树莓派配置成中继路由器；树莓派的wlan0连接wifi做wan口，eth0网口连接电脑做lan口，使电脑可以通过网线连接树莓派上网，并支持ipv6。 ","date":"2025-04-14","objectID":"/posts/3cda1f709fce/:0:0","tags":["Linux Ubuntu"],"title":"Ubuntu配置为路由器","uri":"/posts/3cda1f709fce/"},{"categories":["draft"],"content":"配置网口 wlan0做wan口，连接wifi，设置为dhcp eth0做lan口连接电脑，设置为静态ip 配置如下： vim /etc/netplan/50-cloud-init.yaml network: ethernets: eth0: dhcp4: false addresses: - 192.168.2.1/24 wifis: wlan0: dhcp4: true nameservers: addresses: [8.8.8.8,114.114.114.114,8.8.4.4] access-points: \"HUAWEI-1ER0EH_5G\": password: \"xxxxxxxxxxx\" version: 2 renderer: networkd netplan apply ","date":"2025-04-14","objectID":"/posts/3cda1f709fce/:1:0","tags":["Linux Ubuntu"],"title":"Ubuntu配置为路由器","uri":"/posts/3cda1f709fce/"},{"categories":["draft"],"content":"启用IP转发 编辑文件 vim /etc/sysctl.conf 修改此行 net.ipv4.ip_forward=1 net.ipv6.conf.all.forwarding = 1 应用修改sysctl -p ","date":"2025-04-14","objectID":"/posts/3cda1f709fce/:2:0","tags":["Linux Ubuntu"],"title":"Ubuntu配置为路由器","uri":"/posts/3cda1f709fce/"},{"categories":["draft"],"content":"配置NAT 使用iptables配置NAT，允许局域网设备通过Ubuntu主机访问互联网: iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE ip6tables -t nat -A POSTROUTING -o wlan0 -j MASQUERADE 安装iptables-perisistent保存iptables配置: iptables-save \u003e /etc/iptables/rules.v4 ","date":"2025-04-14","objectID":"/posts/3cda1f709fce/:3:0","tags":["Linux Ubuntu"],"title":"Ubuntu配置为路由器","uri":"/posts/3cda1f709fce/"},{"categories":["draft"],"content":"配置DHCP服务器 安装isc-dhcp-server 配置isc-dhcp-server vim /etc/default/isc-dhcp-server INTERFACESv4=\"eth1\" INTERFACESv6=\"eth0\" vim /etc/dhcp/dhcpd.conf subnet 192.168.2.0 netmask 255.255.255.0 { range 192.168.2.10 192.168.2.200; option routers 192.168.2.1; option broadcast-address 192.168.2.255; option domain-name-servers 8.8.8.8, 8.8.4.4; default-lease-time 600; max-lease-time 7200; } 重启isc-dhcp-server服务 systemctl restart isc-dhcp-server systemctl enable isc-dhcp-server ","date":"2025-04-14","objectID":"/posts/3cda1f709fce/:4:0","tags":["Linux Ubuntu"],"title":"Ubuntu配置为路由器","uri":"/posts/3cda1f709fce/"},{"categories":["draft"],"content":"使用radvd配置dhcpv6 apt install radvd vim /etc/radvd.conf interface eth0 { AdvSendAdvert on; MinRtrAdvInterval 3; MaxRtrAdvInterval 10; prefix 2001:da8:d805:a210:a1::/64{ }; }; systemctl restart radvd systemctl enable radvd ","date":"2025-04-14","objectID":"/posts/3cda1f709fce/:5:0","tags":["Linux Ubuntu"],"title":"Ubuntu配置为路由器","uri":"/posts/3cda1f709fce/"},{"categories":["操作系统"],"content":"操作系统基础 操作系统是直接运行于硬件之上的计算机程序 操作系统用于管理和控制计算机的硬件与软件资源 操作系统为用户软件的开发提供必要的服务和接口 ","date":"2024-09-17","objectID":"/notebook/cd1c15242598/:1:0","tags":["操作系统"],"title":"操作系统基础","uri":"/notebook/cd1c15242598/"},{"categories":["操作系统"],"content":"系统启动流程 上电 运行BIOS 硬件初始化 建立中断向量表 BIOS最后使命：在存储介质中查找主引导区 找到主引导区后，加载运行主引导程序 软件初始化 加载运行操作系统内核 系统初始化 ","date":"2024-09-17","objectID":"/notebook/cd1c15242598/:1:1","tags":["操作系统"],"title":"操作系统基础","uri":"/notebook/cd1c15242598/"},{"categories":["操作系统"],"content":"BIOS(Base Input Output System) BIOS是计算机上电后第一个运行的程序（BIOS属于固件） BIOS首先检测硬件状态，检测通过后立即进行硬件初始化 BIOS会在内存中建立中断向量表（提供硬件访问的方法） BIOS最后将控制权交由主引导程序执行 ","date":"2024-09-17","objectID":"/notebook/cd1c15242598/:2:0","tags":["操作系统"],"title":"操作系统基础","uri":"/notebook/cd1c15242598/"},{"categories":["操作系统"],"content":"BIOS是如何被运行起来的？（BIOS的运行机制） BIOS存储于ROM中，地址映射为0xF0000-0xFFFFF（实地址） BIOS的入口地址为：0xFFFF0 引荐电路的特殊设计使得开机后CPU从0xFFFF0处开始执行 ","date":"2024-09-17","objectID":"/notebook/cd1c15242598/:2:1","tags":["操作系统"],"title":"操作系统基础","uri":"/notebook/cd1c15242598/"},{"categories":["操作系统"],"content":"BIOS最后的使命 按照用于的设置扫描各个存储介质（光驱，软驱，U盘等） 发现主引导区后，将主引导区中的主引导程序载入内存 主引导程序在内存中的入口地址为0x7c00 将控制权交由主引导程序执行jmp 0x7c00 ","date":"2024-09-17","objectID":"/notebook/cd1c15242598/:2:2","tags":["操作系统"],"title":"操作系统基础","uri":"/notebook/cd1c15242598/"},{"categories":["操作系统"],"content":"BIOS如何寻找主引导程序？（主引导区） 位置：位于存储介质的最开始位置处，大小为512字节 特点：前512字节的最后2个有效字节为0x55aa 数据：0x55aa之前的数据被视为主引导程序 汇编基础 $表示当前指令行地址 $$表示当前汇编段起始地址 ","date":"2024-09-17","objectID":"/notebook/cd1c15242598/:2:3","tags":["操作系统"],"title":"操作系统基础","uri":"/notebook/cd1c15242598/"},{"categories":["操作系统"],"content":"调试环境 ","date":"2024-09-17","objectID":"/notebook/cd1c15242598/:3:0","tags":["操作系统"],"title":"操作系统基础","uri":"/notebook/cd1c15242598/"},{"categories":["操作系统"],"content":"命令工具 # 使用nasm编译 nasm boot.asm -o boot.bin # 使用交互方式创建a.img bximage a.img dd if=boot.bin of=a.img bs=512 count=1 conv=notrunc ","date":"2024-09-17","objectID":"/notebook/cd1c15242598/:3:1","tags":["操作系统"],"title":"操作系统基础","uri":"/notebook/cd1c15242598/"},{"categories":["操作系统"],"content":"boot程序:打印字符 org 0x7c00 start: mov ax,cs mov ss,ax mov ds,ax mov es,ax mov si,msg print: mov al,[si] add si,1 cmp al,0x00 je last mov ah,0x0e mov bx,0x0f int 0x10 jmp print last: hlt jmp last msg: db 0x0a,0x0a db \"Hello, DTOS!\" db 0x0a,0x0a times 510-($-$$) db 0x00 db 0x55,0xaa ","date":"2024-09-17","objectID":"/notebook/cd1c15242598/:4:0","tags":["操作系统"],"title":"操作系统基础","uri":"/notebook/cd1c15242598/"},{"categories":["操作系统"],"content":"bochs ","date":"2024-09-17","objectID":"/notebook/cd1c15242598/:5:0","tags":["操作系统"],"title":"操作系统基础","uri":"/notebook/cd1c15242598/"},{"categories":["操作系统"],"content":"安装bochs apt install bochs vgabios which bochs whereis vgabios ","date":"2024-09-17","objectID":"/notebook/cd1c15242598/:5:1","tags":["操作系统"],"title":"操作系统基础","uri":"/notebook/cd1c15242598/"},{"categories":["操作系统"],"content":"bochs启动方式 显示方式：bochs -f bochsrc_file 隐式方式：bochs 命令执行后会在当前路径查找以下配置文件：.bochsrc bochsrc bochsrc.txt ","date":"2024-09-17","objectID":"/notebook/cd1c15242598/:5:2","tags":["操作系统"],"title":"操作系统基础","uri":"/notebook/cd1c15242598/"},{"categories":["操作系统"],"content":"bochs启动文件 # how much memory the emulated machine will have megs:32 #filename of ROM images romimage: file=/usr/local/share/bochs/BIOS-bochs-latest vgaromimage: file=/usr/share/vgabios/vgabios.bin #what disk images will be used # floppya: 1_44=\"freedos.img\", status=inserted floppya: 1_44=\"data.img\", status=inserted #choose the boot disk boot: floppy #where do we send log messages? #log bochsout.txt # disable the mouse mouse: enabled=0 #enable key mapping, usering us layout as default keyboard: keymap=/usr/local/share/bochs/keymaps/x11-pc-us.map ","date":"2024-09-17","objectID":"/notebook/cd1c15242598/:5:3","tags":["操作系统"],"title":"操作系统基础","uri":"/notebook/cd1c15242598/"},{"categories":["draft"],"content":"镜像管理 搜索官方仓库镜像：docker search centos 拉取镜像：docker pull centos 拉去第三方镜像：docker pull index.tenxcloud.com/tenxcloud/httpd 查看当前主机镜像列表：docker image list 删除镜像：docker image rm centos:latest docker image rm [IMAGE ID] 导出镜像：docker image save centos \u003e docker-centos.tar.gz 导入镜像：docker image load -i docker-centos.tar.gz 查看镜像详细信息：docker image inspect centos ","date":"2024-08-17","objectID":"/posts/df6cd2b0b2ad/:1:0","tags":["docker"],"title":"docker用法","uri":"/posts/df6cd2b0b2ad/"},{"categories":["draft"],"content":"容器管理 运行容器：docker run nginx 查看正在运行的容器：docker container ls docker ps 查看所有容器：docker ps -a 查看容器详细信息：docker container inspect 容器名称/id 容器start/stop/kill：docker start/stop/kill 容器名称/id 删除容器：docker rm 容器名称/id 删除所有容器: docker rm -f `docker ps -a -q` ","date":"2024-08-17","objectID":"/posts/df6cd2b0b2ad/:2:0","tags":["docker"],"title":"docker用法","uri":"/posts/df6cd2b0b2ad/"},{"categories":["draft"],"content":"容器启动 启动时交互：docker run -it nginx:latest /bin/bash 退出容器：ctrl+p \u0026 ctrl+q attach进入容器：docker attach 1bf0f43c4d2f -p端口映射：docker run -d -p 8888:80 nginx:latest #-p hostPort:containerPort -d detach 挂载时创建卷：`docker run -d -p 80:80 -v /data:/usr/share/nginx/html nginx:latest ","date":"2024-08-17","objectID":"/posts/df6cd2b0b2ad/:3:0","tags":["docker"],"title":"docker用法","uri":"/posts/df6cd2b0b2ad/"},{"categories":["draft"],"content":"volume管理 创建卷：docker volume create [volume name] 查看卷列表：docker volume ls 查看卷信息：docker volumn inspect [volumn_name] 使用卷创建：docker run -d -p 9000:80 -v clsn:/usr/share/nginx/html nginx:latest ","date":"2024-08-17","objectID":"/posts/df6cd2b0b2ad/:4:0","tags":["docker"],"title":"docker用法","uri":"/posts/df6cd2b0b2ad/"},{"categories":["draft"],"content":"配置容器镜像 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [ \"https://docker.m.daocloud.io\", \"https://dockerproxy.com\", \"https://docker.mirrors.ustc.edu.cn\", \"https://docker.nju.edu.cn\" ] } EOF sudo systemctl daemon-reload sudo systemctl restart docker ","date":"2024-08-17","objectID":"/posts/df6cd2b0b2ad/:5:0","tags":["docker"],"title":"docker用法","uri":"/posts/df6cd2b0b2ad/"},{"categories":["笔记"],"content":"静态链接 ","date":"2024-07-11","objectID":"/notebook/9c8304407540/:1:0","tags":["程序员的自我修养"],"title":"4静态链接","uri":"/notebook/9c8304407540/"},{"categories":["笔记"],"content":"目标文件的格式 现在PC平台流行的可执行文件格式主要时Windows下的PE（Portable Executable）和Linux的ELF（Executable Linkable Format），它们都是COFF（Common file format）格式的变种。 目标文件就是源文件编译后但未进行链接的那些中间文件（Windows的.obj和Linux的.o），它跟可执行文件的内容与结构很相似，所以一般跟可执行文件格式一起采用同一种格式存储。 从广义上看，目标文件与可执行文件的格式其实几乎是一样的，所以我们可以广义地将目标文件与可执行文件看成事一种类型的文件，在Windows下，我们可以统称他们为PE-COFF文件格式。在Linux下，我们可以将他们统称为ELF文件。 静态链接库稍有不同，它是很多目标文件捆绑在一起形成一个文件，再加上一些索引，可以简单的把它理解为一个包含有很多目标文件的文件包。 可重定位文件（Relocatable File）：这类文件包含了代码和数据，可以被用来链接成可执行文件或共享目标文件，静态链接库也可以归为这一类。例，Linux的.o和Windows的.obj 可执行文件（Executable File）：这类文件包含了可以直接执行的程序，它的代表就是ELF可执行文件。 共享目标文件（shared Object File）：Linux的so和Windows的DLL 核心转储文件（Core Dump File）：Linux下的core dump ","date":"2024-06-10","objectID":"/notebook/16b9b184070f/:1:0","tags":["程序员的自我修养"],"title":"3目标文件的格式","uri":"/notebook/16b9b184070f/"},{"categories":["笔记"],"content":"目标文件是什么样的 目标文件中的内容有编译后的机器指令代码，还包括了链接时所需要的一些信息，比如符号表、调试信息、字符串等。一般目标文件将这些信息按不同的属性，以节Section的形式存储，有时候也叫段Segment。 .text: 保存编译后的机器码 .data: 保存已初始化的全局变量和局部静态变量 .bss: (Block Started by Symbol)bss段只是为未初始化的全局变量和局部静态变量预留位置，它并没有内容（默认值都是0）。 .rodata段: 用于存放只读数据，一般数程序里面的只读变量，如const修饰的变量和常量字符串 static int x1 = 0; // 在.bss段 static int x2 = 1; // 在.data段 // 初始化为0可以认为是未初始化,所以被优化掉了可以放在bss段 总体来说，程序源代码被编译后主要分为两种段，程序指令和程序数据。代码段属于程序指令，而数据段和.bss属于程序数据。 ","date":"2024-06-10","objectID":"/notebook/16b9b184070f/:1:1","tags":["程序员的自我修养"],"title":"3目标文件的格式","uri":"/notebook/16b9b184070f/"},{"categories":["笔记"],"content":"为什么把程序指令和数据分开放？优点是什么？ 一方面是当程序被装载后，数据和指令分别被映射到两个虚拟区域，由于数据区域读进程来说是可读写的，而指令区域对进程来说是只读的，所以这两个虚存区域的权限可以分别被设置成可读写和只读。这样可以方式程序的指令被有意或无意的改写。 另一方面是对于现代的CPU来说，它们有着极为强大的缓存（Cache）体系。由于缓存在现代的计算机中地位非常重要，所以程序必须尽量提高缓存命中率，指令区和数据区的分离有利于提高程序的局部性。现代CPU的缓存一般都被设计成数据缓存和指令缓存分离，所以程序的指令和数据被分开存放对CPU的缓存命中率提高有好处。 第三个原因是共享指令。当系统中运行着多个该程序的副本时，它们的指令都是一样的，所以内存中只需要保存一份该程序的指令部分。对于指令这种只读的区域来说是这样，对于其他的只读数据也一样，比如很多程序里面带有的图标，图文，文本等资源也是数据可以共享的。当然每个副本进程的数据区域是不一样的，它们是进程私有的。 对于全局变量来说，如果初始化了不为0的值，那么该全局变量则被保存在data段，如果初始化的值为0，那么将其保存在bss段，如果没有初始化，则将其保存在common段，等到链接时再将其放入到BSS段。关于第三点不同编译器行为会不同，有的编译器会把没有初始化的全局变量直接放到BSS段。 原文链接 COMMON块详解 ","date":"2024-06-10","objectID":"/notebook/16b9b184070f/:1:2","tags":["程序员的自我修养"],"title":"3目标文件的格式","uri":"/notebook/16b9b184070f/"},{"categories":["笔记"],"content":"自定义段 GCC提供了一个扩展机制，可以指定变量所处的段： __attribute__((section(\"FOO\"))) int global = 42; __attribute__((section(\"BAR\"))) void foo() {} ","date":"2024-06-10","objectID":"/notebook/16b9b184070f/:1:3","tags":["程序员的自我修养"],"title":"3目标文件的格式","uri":"/notebook/16b9b184070f/"},{"categories":["笔记"],"content":"binutils(readelf, objdump, nm)常用工具及用法 # -s 显示所有请求section的内容 # -d 反汇编 objdump -s -d SimpleSection.o # 读取ELF头信息 readelf -h SimpleSection.o # 读取段表头信息 section header readelf -SW SimpleSection.o objdump -h SimpleSection.o ","date":"2024-06-10","objectID":"/notebook/16b9b184070f/:1:4","tags":["程序员的自我修养"],"title":"3目标文件的格式","uri":"/notebook/16b9b184070f/"},{"categories":["笔记"],"content":"ELF文件结构描述 ELF目标文件格式的最前部是ELF文件头，它包含了描述整个文件的基本属性，比如ELF文件版本，目标机器型号，程序入口地址等。 详见章节3.4节 ","date":"2024-06-10","objectID":"/notebook/16b9b184070f/:1:5","tags":["程序员的自我修养"],"title":"3目标文件的格式","uri":"/notebook/16b9b184070f/"},{"categories":["笔记"],"content":"链接的接口：符号 在链接中，目标文件之间的相互拼合实际上是目标文件之间对地址的应用，即对函数和变量的地址的引用。我们将函数和变量统称为符号，函数名和变量名统称为符号名。几种不常用到的符号： nm查看符号表：nm SimpleSection.o ","date":"2024-06-10","objectID":"/notebook/16b9b184070f/:2:0","tags":["程序员的自我修养"],"title":"3目标文件的格式","uri":"/notebook/16b9b184070f/"},{"categories":["笔记"],"content":"extern “C” extern语法规则 // 写法一 extern \"C\" { int func(); int var; } // 写法二 extern \"C\" int func(); extern \"C\" int var; // 导出CPP中的符号 extern \"C\" double _ZN6myname3varE; 导出cpp命名空间中的变量 #include \u003cstdio.h\u003e namespace myname { int var = 42; } extern \"C\" double _ZN6myname3varE; // 定义不会报错, 使用时会有问题 // extern \"C\" int _ZN6myname3varE; // 正确定义 int main(int argc, char* argv[]) { printf(\"%d\\n\", myname::var); // 42 printf(\"%d\\n\", *(int*)\u0026_ZN6myname3varE); // 42 printf(\"%d\\n\", int(_ZN6myname3varE)); // 0 return 0; } ","date":"2024-06-10","objectID":"/notebook/16b9b184070f/:3:0","tags":["程序员的自我修养"],"title":"3目标文件的格式","uri":"/notebook/16b9b184070f/"},{"categories":["笔记"],"content":"强符号和弱符号 强符号：编译器默认函数和初始化的全局变量为强符号 弱符号：未初始化的全局变量为弱符号。也可以通过__attibute__((weak))来指定。 注意，强符号和弱符号都是针对定义来说的，不是针对符号引用。 编译器关于强弱符号的规则有： 强符号不允许多次定义，但强弱可以共存； 强弱共存时，强覆盖弱； 都是弱符号时，选择占用空间最大的，如选择double类型的而不选择int类型的。 变量名称 初始化 未初始化 全局变量 .data .common 静态全局变量 .data .bss 静态局部变量 .data .bss int g_init_var = 10; // .data static int sg_init_var = 20; // .data int g_uninit_var; // .common static int sg_uninit_var; // .bss int main(int argc, char* argv[]) { static int sl_init_var = 30; // .data static int sl_uninit_var; return 0; } 强引用和弱引用详见3.5.5 ","date":"2024-06-10","objectID":"/notebook/16b9b184070f/:4:0","tags":["程序员的自我修养"],"title":"3目标文件的格式","uri":"/notebook/16b9b184070f/"},{"categories":["笔记"],"content":"温度而知新 北桥：负责CPU，GPU，内存等高速设备。南桥：负责键盘，鼠标，硬盘等低速设备 运行库使用操作系统提供的系统调用接口（System Call Interface），系统调用接口在实现中往往以软件中断（Software Interrupt）的方式提供，比如Linux使用0x80号中断作为系统调用接口，Windows使用0x2E号中断作为系统调用接口（从Windows XP Sp2开始，Windows开始采用一种新的系统调用方式）。 操作系统的一个功能是提供抽象的皆苦，另外一个主要功能是管理硬件资源。 线程优先级改变一般有三种方式： 用户指定优先级 根据进入等待状态的频繁程序提升或降低优先级 长时间得不到执行而被提升优先级 ","date":"2024-06-10","objectID":"/notebook/a53d55b01c51/:1:0","tags":["程序员的自我修养"],"title":"2编译和链接","uri":"/notebook/a53d55b01c51/"},{"categories":["笔记"],"content":"编译步骤 编译分为4个步骤：预处理、编译、汇编、链接 ","date":"2024-06-10","objectID":"/notebook/a53d55b01c51/:2:0","tags":["程序员的自我修养"],"title":"2编译和链接","uri":"/notebook/a53d55b01c51/"},{"categories":["笔记"],"content":"预处理 预处理过程主要处理那些源代码文件中的以“#”开始的预编译指令。比如“include”，“#define”等 gcc -E hello.c -o hello.i cpp hello.c \u003e hello.i ","date":"2024-06-10","objectID":"/notebook/a53d55b01c51/:2:1","tags":["程序员的自我修养"],"title":"2编译和链接","uri":"/notebook/a53d55b01c51/"},{"categories":["笔记"],"content":"编译 编译过程就是把预处理完的文件进行一系列词法分析，语法分析，语义分析及优化后生成的相应的汇编代码文件，这个过程往往是我们所说的整个程序构建的核心部分，也是最复杂的部分之一。 gcc -S hello.i -o hello.s /usr/lib/gcc/x86_64-linux-gnu/8/cc1 hello.c ","date":"2024-06-10","objectID":"/notebook/a53d55b01c51/:2:2","tags":["程序员的自我修养"],"title":"2编译和链接","uri":"/notebook/a53d55b01c51/"},{"categories":["笔记"],"content":"汇编 汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。 as hello.s -o hello.o gcc -c hello.s -o hello.o ","date":"2024-06-10","objectID":"/notebook/a53d55b01c51/:2:3","tags":["程序员的自我修养"],"title":"2编译和链接","uri":"/notebook/a53d55b01c51/"},{"categories":["笔记"],"content":"链接 链接过程主要包括了地址和控件分配、符号决议和重定位等这些步骤。最基本的静态链接，每个模块的源代码文件（如.c）文件经过编译器编译成目标文件（ObjectFile，一般扩展名为.o或.obj），目标文件和库（Library）一起链接形成最终可执行文件。而最常见的库就是运行时库 为什么汇编器不直接输出可执行文件而是输出一个目标文件呢？ 链接过程到底包含了什么内容？ 为什么要链接？ ","date":"2024-06-10","objectID":"/notebook/a53d55b01c51/:2:4","tags":["程序员的自我修养"],"title":"2编译和链接","uri":"/notebook/a53d55b01c51/"},{"categories":["draft"],"content":"hugo hugo创建新文章 hugo new posts/xxx.md hugo new content posts/xxx.md hugo启动项目 hugo server -D # build草稿文章 hugo server --buildDrafts # 实时预览 hugo server -D --disableFastRender md增加全角缩进\u0026emsp;, 半角缩进\u0026ensp; ","date":"2024-05-28","objectID":"/posts/bd4437ab5963/:1:0","tags":["Linux"],"title":"常用指令记录","uri":"/posts/bd4437ab5963/"},{"categories":["draft"],"content":"iptables 查看INPUTt表: iptables -L INPUT -n --line-numbers 追加到INPUT表: iptables -A INPUT -s 42.192.6.197 -j DROP ","date":"2024-05-28","objectID":"/posts/bd4437ab5963/:2:0","tags":["Linux"],"title":"常用指令记录","uri":"/posts/bd4437ab5963/"},{"categories":["draft"],"content":"git git远程删除分支git push origin --delete remotebranch 和 git push origin :remotebranch less用法 less可以使用鼠标滚轮翻页，-N显示行号 -e显示百分比 less 向上翻页 向下翻页 一页 k j 空格 半页 u (up) d (down) 一行 b f 回车 ","date":"2024-05-28","objectID":"/posts/bd4437ab5963/:3:0","tags":["Linux"],"title":"常用指令记录","uri":"/posts/bd4437ab5963/"}]